


* Design Decisions:
  Not going to use moveit.
  Moveit is designed to be used with robot arms and is mostly concerned with
  path planning of end effectors and not mobile robots. So, it would probably
  not work for my purposes.


* Plan:
  First, set up octomap.
  Then using a blank octomap with fake obstacles,
  Use OMPL to do RRT path planning as a rosnode.
  Then integrate it with either move_base(ros1)
  or navigation(ros2).
  Then create a dynamic planner to integrate with
  move_base/navigation.
  organize the code you have written a bit better into different files.
  
* DONE Look Into Quaternion Integration
  Specifically, theres a function in rbdl, that allows me to 
  use a different scheme for quaternion integration.
  Tried both linear approximation and instantaneous axis-angle rotation
* DONE Dynamic planning
  1. Clean up existing global planner code into a single class.
  2. Create main file that includes both global and local planners. Integrate them.
  3. Understand Jackal Gazebo Simulation.
  4. Global Planner will need to operate on Empty_World map somehow.
    a. Possibly use CERL's octomap implementation.
  4. Create Dynamic Window Planner
    a. This is going to have to work with sensors to update the map and stuff.
    b. Will need a mapping software like Octomap. Talk to Matt Richards.

  
  

  
* DONE Octomap/RTabMap
  1. Visualize the rosbag file from cerl. (Nope. Will use the freiburg campus)
  2. Load it into gazebo somehow as a world file.
  3. Figure out a way to use it to create a global map.
  4. Run the jackal in this global map and perform local planning.
     Will need a control system to follow the waypoints.
  
  An RTabMap of the Freiburg campus is generated.
  I need to edit the auvsl_planner launch file to run the RTabMap, Jackal Gazebo sim,
  and the auvsl_planner node.
  
  Somehow convert an rtabmap into a gazebo world
  Create point cloud from rtabmap laser scans.
  Use meshlab to convert point cloud to mesh
  

  1. Request a complete octomap from RTabMap from the auvsl_planner node
  2. Do global planning on the octomap with a low level of fidelity.
     Set octomap resolution to like a meter or something
  3. Do Local planning on the octomap with a much higher level of fidelity
     Or use RTabMap to request a 2d occupancy grid.
  4.
  

** Status  
   I've got Rtabmap working. I can subscribe to the velodyne and build a map.
   I can localize in the map, segment obstacles and ground.
   Now I should focus on trying to do path planning with these new maps.




* DONE Implementing D* in move_base
  Okay. This is going to be a big one I think.
  1) Run a separate thread for DStarPlanner
  2) Move base will call computeVelocityCommands from info generated in move_base
     computeVelocityCommands will get the next waypoint from D* and using a control system, compute velocity commands to reach it
     runPlanner thread will wait until vehicle odometry shows that the vehicle has reached the next waypoint
  3) Going to use a followBackpointer() function to physically make sure the robot follows the back pointer
     by waiting for odometry to show that it literally has done so.
  4) Need to first get global terrain and obstacle point cloud. Make these class variable and hold onto them
     Local planning area will be like 10x10m
     When initializing D* planner use a spatial window to filter obstacle and terrain point clouds to
     get points that only lie within planning area and then generate occupancy grid with the window pcls
  5) Run segmentation on updated local point cloud with every new lidar scan? Could be way too slow.

  Status: confirmed that it is following paths.
  The control system is pretty timid. I should up the gain a shit ton. Also the "reached waypoint threshold" is pretty strict. I should
  relax it. Uh. I need to fix the visualization in rviz. Its not showing the states and obstacles for some reason. I need to verify
  that it is able to detect new obstacles and path around them as well.
  I should experiment with the other method of ground/obstacle segmentation.
  
  I noticed that edge costs are only updated once. and the update is 16,000. So lets try to find out why with a fake update.
  The updateEdge callback is not being called.
  I replace the topic with /clock and it got called every second as expected.
  do your own segmentation. rtabmap sucks.

  Reset the rtabmap. It's not publishing. And not aggregating lidar scans. I don't know why. The lidar detects the new obstacle but it
  doesn't show up in the rtabmap pointcloud.
     
** DONE Implement or refractor local cost map functions
   I believe this is done.
** DONE Uh, How do I actually cause the local planner to get called???
   After looking at the source code, I believe the answer is that setting a goal through the goal topic starts everything
   It causes a callback to be activated, runs the global planner, then starts a loop where the local planner runs.
   The main loop exits when the goal is reached.
   Yeah. Except instead of a goal topic, its an actionserver. Which is essentially the same thing I think.
   
** DONE Do not use costmap_ros because it sucks
   I need to be get map updates directly and not have to iterate
   the entire map. Also, the resolution of the costmap_ros doesn't
   really match the distance between waypoints anyway. Its just not
   good for what I want.



* DONE D* algorithm
  Basic implementation finished.
  Can determine a path in the presence of dynamic obstacles.
  World map is very simple at this point
  Cost map is also very simple.
  No heuristics yet.

** TODO Simple Heuristic
   To guide search. Use euclidean distance for now.
   This might not be admissible/consistent with respect to the
   cost function. Because the cost function is going to become
   pretty complex. So it might not make sense to implement a heuristic
   Also it may not be necessary. Algorithm is already pretty fast.
   This is low priority.

** TODO Complex Cost function
   Cost function that estimates traversability
   1. Online simulation of vehicle to determine which neighboring states are reachable
      and estimate how safe each state is and total time of traverse
      This is probably not feasible for realtime operation (~10Hz).
   2. Offline precomputation of which neighboring states are reachable, how safe the states are
      and how long it would take to reach the state.
      1. Possibly use a neural network to model possibility of roll-over at a state
      2. Offline precomputation will be include traversing from lower to higher terrain,
         higher to lower terrain, and staying on flat terrain. Then running simulations to
         determine the minimum safe velocities. idk.




** TODO Complex world map plus jackal nodes
   Simulate whole Jackal in gazebo
   rely on ros nodes for localization
   Use perception for obstacle detection and updating map in D*
   Integrate planners with a control system
   the online loop in D* will have to actually control
   the vehicle and physically follow the D* backpointers
   
   
   


* DONE RRT
  In general, this is done.

** Smoother trajectories
   Include a low pass filter on velocity commands
   so that velocity command smoothly transitions to from old to new command

** TODO SST
   Sparse Stable RRT
   asymptotically optimal
   also apparently sparse so hopefully it doesn't expand a bunch of nodes that are all close together



  

* DONE Make a useful altitude map from rtabmap
  Wow this was tough. 
  Point cloud of ground obtained.
  Point cloud is polynomial smoothed using pcl
  need to query smoothed cloud for nearest neighbors to a point.
  Then compute a weighted average based on distance. That should
  be it I hope.
  Might need to process the entire map this way and store it as
  a 2d array then query that array. Oh well. DONE. DONE. DONE.
  
* OMPL
  WTF why is it so hard. I guess I need to read the tutorial shit.

  Done: 1. Create ODE based state propagator class. using jackal dynamic model.
  Dont: 2. Don't implement your own state sampler class. Use SteeredControlSampler.
                 I'm not sure steeredcontrolsampler is what I need. I think I should use SimpleDirectControlSampler
  Done: 2. Use SimpleDirectedControlSampler. This requires a controlsampler to be passed to si_.
  Done: 3. Implement a controlsampler. Iterate over possible control values.
           (Currently using default random control sampler which is stupid)
  Done: 4. Do implement JackalStatePropagator. give JackalStatePropagator to SpaceInformation.


  !!!use control/* not geometric/*!!!

  Use realvectorstatespace as usual

  Find out about distance function. Its L2 norm implemented in RealVectorStateSpace.
  Distance function gets used in the nearest neighbor calculations.
  It might be good to actually just leave it how it is. Probably not.
  

* DONE Intelligent state sampling
  Make the state space sampler more likely
  to sample in a region around the node that
  is closest to the goal. Prevent unnecessary
  exploration of the state space.

* DONE Prevent Excessive Skidding
  This isn't Tokyo drift. Computing Vl and Vr from Vf and W using kinematic approx might be dumb.
  Perhaps a better idea is just to do Vl = Vf - W and Vr = Vf - W
  So that way the total difference between tire velocities is limited to prevent skidding.
  This is actually not really different from the current approach. Shit.
  I fixed this problem be adding PID control for the tires. When you consider
  the torque on the tires, everything works better for some reason.
  Also added a simple heuristic for tire reaction torque based on slip. Its a hack. I don't care.

* DONE Smarter Control Sampling
  Sample omega's such that (~omega*duration) + heading = heading towards target
  Sample forward velocities such that (~Vf*duration) + position = target_position

  Where ~omega is required omega + small random sampling
        ~Vf is required Vf + small random sampling

  Working on it.

* DONE Smart Distance Function
  Only Penalize velocity if it is not in the direction towards
  the goal state. So do a dot product. Before I implement this,
  I'm going to have to convert from RBDL velocity to world frame
  velocity. RBDL floating based velocity representation is painfully
  bad. Fortunately I figured it out long ago through trial and error
  and suffering. Note RBDL linear velocity actually matches real linear
  velocity. Oh.

* LPF the vehicle controls to produce smoother trajectories
  I belive the jackal state propagator can take into account the previous control
  and I can provide a short interpolation between previous and current controls
  to ensure smoother motion.
  update. I don't have access to the previous control.

* <2021-07-30 Fri> Update...
  My terrain map is working. It is smooth and segments point cloud pretty well.
  Will test more global planning tomorrow and make sure it is returning a path plan.
  Then I will move on to local planning with ROS.
  Need to verify terrain grid interpolates correctly
* <2021-07-22 Thu> Update
  Its going pretty good I guess.
  RRT is simulating in RVIZ but some of the simulation is fucked. I think it is hitting an obstacle

* <2021-03-18 Thu> Update
  Kinematic model planner is working. Dynamic model planner is not working. Visualizer is working.
  It is cool.
  
* <2021-08-25 Wed> Update
  RRT planning esta completo forget about it.
  Local planning is difficult because of obstacle detection.
  Localization has to be really good, or saved ground plane won't
  match the orientation of the sampled ground plane and the 
  segmentation code will not work because it will see two planes.
  Segmentation is tuned for the local planner to be conservative in
  identifying obstacles so it doesn't classify the ground as obstacle
  Segmentation/obstacle detection is slow af ~3s to run.
  It's not currently following b_ptrs or anything. Idk why.
  Important to note that ros::spin() is located in move_base node.
  It is always running as long as move_base is running.
  I wish they used a multithreaded spinner.
  I think the computeVelocityCommand is not getting called because
  ros::spin() is spending all its time on segmenting point clouds.
  I'm going to have to increase the processing speed by down
  sampling otherwise this is never going to work in realtime.
  Also getting rid of the publishing will definitely help.

  Vehicle is not publishing velocity commadns. I believe its because
  ros.spin() is spending all of its time in the updateEdgeCostsCallback
  and leaving no time for computeVelocityCommands. But idk.
  
  You are going to have to rely on point cloud density alone probably.
  I don't think segmentation can be done fast enough. Region growing
  isn't fast enough. Maybe voxel filter would fix it but I'm not sure.
  What I am sure of is that iterating through the point cloud and updating
  the grid directly by mapping point to grid location would be fast.
  I can probably make it work.

  
* <2021-09-27 Mon> Update
  So I've run the vehicle off-road and collected some data and run simulation to compare against it.
  Now what? I should try to run the planner, and also increase model performance somehow.
  Could increase collision checking resolution I guess.
  I experimented with elevation map smoothing.
  I wrote code to select the best soil params.
  Need to find answer to "what amount of accuracy is necessary/acceptable/standard"
  Need to retrain tire network to add Ty to the output instead of the current stupid hack that you are doing

* <2021-09-29 Wed> Update
  Well, I tuned the dynamic model to achieve good performance.
  Next step is to go back to rantoul or whatever and collect data from a longer test.
  Also more tests involving circular paths and measuring radius.
  Also test global planner.
  See if I can go to some place nearby as well. 
  Driving to Rantoul is pretty annoying.
  Maybe I can go to Grainge grove. Probably not. Also no extension chord there.
  
  Wait. I don't need to go anywhere to test the global planner.
  I can just run that on my computer. Retard.
  I guess I need to tune the occupancy grid and thats all.
  Actually, I should run the gp on the jackal, not my desktop.
  I think I will need to install ompl.

  New Idea. Modify Global Planner.
  Use steering instead of random propagation.
  Implement steering function, using ANFIS control system
  Instead of sampling a few random ass controls, use anfis to steer
  to sampled points. I've noticed the RRT gets stuck a lot by 
  choosing the same stupid paths and its unable to reach the new points.
  So hopefully this helps with that. Could result in speed up because
  it won't have to sample a bunch of random ass controls and run trajectories
  to see which random ass control was best.

  Will implement a function in vehicleRRT called steerWhileValid()
  
  Current problem: it doesn't seem to be approaching the goal in rviz.
  It's moving perpendicular to it. Sometimes it claims to reach the goal though, which is odd.
  
* <2021-10-08 Fri> Update
  I did all that shit in the last update.
  I then tested dynamic model on data/map from rantoul 120m trajectory
  Also the circle. test.
  long test was great. circle test not great. Possibly bad odometry (I dont really thnk so)
  Probably just bad dynamic model estimation blah blah blah.
  I don't know how to fucking improve this shit. SO let it ride.
  
  next step is to think of a way to use surface normals instead of
  iterating.
  Also need to profile code and see where its slow.
  Decided I'm not going to do either of these.
  I still need to iterate to find exactly where the tire intersects
  the soil. I could actually use surface normals to solve this.
  But I won't bother.
  
  Don't need to profile really.
  I think I'm done here. tbh.
  Focus on the paper and try to make the vectornav imu work.
  Also, go ahead and play with neural network for dynamic model.
  
  
* <2021-10-20 Wed> Update
  Model performance seems very inconsistent.
  for different elevation map_res_, can get very different results.
  I am pretty sure I have got all my transforms correct this time.
  Don't bother changing the interpolation code.
  DOn't add any new features. Just finish it and move on.
  You can go back to writing the paper.
  Thursday, record more tests.
  
* <2021-10-21 Thu> Update
  Big problems.
  I assume the map is poorly made. Unfortunate.
  This is due possibly to imu localization being bad because the map is on a slope
  might not actually exist. Also, imu noise affects the lidar transformation to
  world frame and possibly also fucks things up. Will wait for vectornav IMU
  and hopefully that improves things.
  Will work on the paper for now.
  
  Vehicle Takes a stupid sharp turn when using map res of .1
  Lets find out why by plotting altitude under each tire.
  I plotted altitude and there are some sharp changes in altitude that could be
  causing the problem. Also there are some slopes as well. But I cant say for sure
  wtf is causing the vehicle to turn like it is. Its possible that some of the 
  tires lose traction. That could be it. I'm going to plot sinkage.
  Not sure what causes it to turn. I looked at the sinkage and altitude and didn't
  see anything amiss.
  I'm sure that all my transformations are correct.
  One important thing to note is that the error improves when I decrease the map
  resolution as expected, things become more smoothed out.

  I am going to test all the components.
  I am going to test the gaussian blur by creating a terrain map that
  is just alternating -1 and 1 so it should blur to zero.
  Gaussian blur smoothed things out to around 0.

  I get the lowest error when I use th flat map and complex cpt.
  I can validate the rot_y(theta) part by adding an angle offset
  of like pi/4 and I should see the vehicle sink a lot more when
  I animate it in matlab.
  I did this, and plotted the cpt and vehicle normals, and it
  there was a pi/4 degree angle between the vectors as I expect.
  Angle was around y axis.

* DONE Stick IMU to jackal
  Compare to the vectornav imu odometry msg to ekf_localization
  odom message.
  Add vectornav imu odom to ekf_localization compare to ekf
  without.
  Will need to create 2 ekf nodes.
  Will need to attach the vectornav imu. with duct tape or something.
  
2 problems  
* Inconsistent with different elevations
  Very bad error sometimes.
  Even altitude differences on the order of floating point error 1e-5
  result in significant trajectory deviations. I can't even believe this.
  Will test by adding Random noise to elevation map.
  Checks out. ADding noise on order 1e-4 results in meter differences
  of the final trajectory.
  Will need to demonstrate the chaotic nature of the problem in paper.
  Need to validate tire transforms. Plot all 4 cpt positions. Done.
  To demonstrate chaotic nature of the model,
  Plot long trajectory multiple times, adding noise to the initial x y position.
* DONE DO this:
  train new network. pick best soil params for test data.
  Generate plots for CV and Long Distance.
  Done.

  Figure out a god damn odom solution for the jackal.
  Start with vectornav.
  Maybe then try realsense.
  Did both and done.
* DONE Make unit tests for dynamic model
  1. Verify the velocities in the tire frame.
* TODO Reduce model error
  Options:
  1. Learn a network to predict model residual to reduce error.
  Must therefore first generate the data by running on the 
  training set. For every timestep, generate a correction with the neural network.
  Not so easy. Will need to collect a full state vector including position and velocity.
  Could be rather painful. May be better off using finite differences.
  
  2. Finite differences for tire network. Bold.
     Will not work. performance is extremely chaotic with
     respect to tire network params. finite differences will
     not converge. If you did an average over several runs
     maybe it would be less chaotic but it would take much
     more time. Way too much time to run.
  
  3. Full neural network model. Sick. 
     Also easiest. And easy to verify if its working.
     If it doesn't work, I'll know and be able to give up rapidly.
     Tried a little bit and couldn't make it work. 
     I don't think it ever will. I don't even think
     neuralODE's will work either.
     
  4. Understand which bekker parameters affect Fy and search them. 
     I dont think this is a promising strat. but its easy and Ishould try.
     Fy increases with kc
     Fy increases with kphi
     Fy increases with phi
     Okay, increasing or decreasing these doesn't seem to have much of an effect on decreasing turn radius.
     Searching For better bekker tire params is not going to work.
     Finite Differences for tire params didn't work any better than
     brute force search. Limited performance improvements.

  5. Neural network to predict vx,vy,wz. Then fuse result with 
     dynamic model. Need more features.
     Acceleration? Lets try it. Lateral acceleration is related to turn radius.
     Best NN prediction results with a feature vector that just includes [qd1,qd3] for the past 8 timesteps.
     Hopefully this approach works for real world data.


* Different results depending on loading pcl from file. 
  This is due to floating point error in the file.
  I believe. Code runs the same as long as I load the
  point clouds from file. Diff of the elevation maps shows
  that floating point error exists.
  
* DONE Verified all spatial and homogenous transformations.

  
* Minimum Viable Product:
** DONE RRT Algorithm
   Do it with ompl

** Double D*
   Can't be done with ompl. Must implement from scratch.


* Nice To Have:
** Multithreading
   Use multiple threads to explore vehicle states faster

** URDF for specifying dynamic model
   Load URDF into rbdl instead of manually specifying
   vehicle description.
   So you can swap it out for other vehicle models.
** DONE Configuration file for all parameters. YAML format maybe. I think ROS has a way to do this.
   Numerous parameters that could be adjusted between runs.
   Fuzzy constant speed.
   Max angular vel
   Planner goal bias
   Planner resolution
   Dynamic model ode time step

